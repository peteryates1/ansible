---
# Restart a VM and mount all attached filesystem shares.
# Use after attaching shares with share-dir config_only=true.
#
# Usage:
#   ansible-playbook playbooks/mount-shares.yml -e vm_name=jop01

- name: Restart VM and discover shares
  hosts: localhost
  become: true

  vars:
    requested_vm_name: "{{ vm_name | default('') }}"
    requested_vm_user: "{{ vm_user | default('peter') }}"
    requested_host_ssh_user: "{{ host_ssh_user | default(lookup('env', 'SUDO_USER') | default(lookup('env', 'USER'), true)) }}"

  tasks:
    - name: Validate inputs
      fail:
        msg: "Usage: ansible-playbook playbooks/mount-shares.yml -e vm_name=<name>"
      when: requested_vm_name == ''

    - name: Check VM existence
      command: virsh list --all --name
      register: vm_list
      changed_when: false

    - name: Fail when VM does not exist
      fail:
        msg: "VM '{{ requested_vm_name }}' does not exist."
      when: requested_vm_name not in vm_list.stdout_lines

    - name: Extract filesystem shares from VM XML
      shell: |
        set -euo pipefail
        virsh dumpxml --inactive "{{ requested_vm_name }}" | awk '
          BEGIN { infs=0 }
          /<filesystem/ { infs=1; src=""; tag=""; fstype="9p"; next }
          infs && /<driver[[:space:]]/ {
            if ($0 ~ /type=.virtiofs./) fstype="virtiofs"
            next
          }
          infs && /<source[[:space:]]/ {
            gsub(/.*dir=["\047]/, "")
            gsub(/["\047].*/, "")
            src=$0
            next
          }
          infs && /<target[[:space:]]/ {
            gsub(/.*dir=["\047]/, "")
            gsub(/["\047].*/, "")
            tag=$0
            next
          }
          infs && /<\/filesystem>/ {
            if (src != "" && tag != "") print src "|" tag "|" fstype
            infs=0
          }
        '
      args:
        executable: /bin/bash
      register: share_list
      changed_when: false

    - name: Parse share list
      set_fact:
        detected_shares: >-
          {{
            share_list.stdout_lines | default([])
            | map('regex_replace', '^([^|]+)\|([^|]+)\|([^|]+)$', '{"source": "\1", "tag": "\2", "fs_type": "\3"}')
            | map('from_json')
            | list
          }}

    - name: Display detected shares
      debug:
        msg: "Found {{ detected_shares | length }} share(s): {{ detected_shares | map(attribute='source') | join(', ') }}"

    - name: End play if no shares found
      meta: end_play
      when: detected_shares | length == 0

    - name: Check VM state
      command: virsh domstate {{ requested_vm_name | quote }}
      register: vm_state
      changed_when: false

    - name: Shutdown VM if running
      command: virsh shutdown {{ requested_vm_name | quote }}
      when: "'running' in (vm_state.stdout | lower)"
      register: vm_shutdown
      changed_when: vm_shutdown.rc == 0

    - name: Wait for VM to power off
      shell: |
        state="$(virsh domstate {{ requested_vm_name | quote }} | tr '[:upper:]' '[:lower:]')"
        if echo "$state" | grep -q "shut off"; then exit 0; fi
        exit 1
      args:
        executable: /bin/bash
      register: vm_poweroff_wait
      changed_when: false
      retries: 30
      delay: 2
      until: vm_poweroff_wait.rc == 0
      when: vm_shutdown is changed

    - name: Start VM
      shell: |
        set -euo pipefail

        vm="{{ requested_vm_name }}"
        start_out="$(virsh start "$vm" 2>&1)" && {
          echo "started"
          exit 0
        }
        echo "$start_out" >&2

        if ! echo "$start_out" | grep -qi "Did not find USB device"; then
          exit 1
        fi

        xml_file="$(mktemp /tmp/${vm}-domain-XXXXXX.xml)"
        clean_xml_file="$(mktemp /tmp/${vm}-domain-clean-XXXXXX.xml)"
        cleanup() {
          rm -f "$xml_file" "$clean_xml_file"
        }
        trap cleanup EXIT

        virsh dumpxml "$vm" > "$xml_file"
        awk '
          BEGIN { skip=0 }
          /<hostdev[^>]*type=.usb./ { skip=1 }
          !skip { print }
          skip && /<\/hostdev>/ { skip=0 }
        ' "$xml_file" > "$clean_xml_file"

        if cmp -s "$xml_file" "$clean_xml_file"; then
          echo "Failed to start VM and no removable USB hostdev blocks were found." >&2
          exit 1
        fi

        virsh define "$clean_xml_file" >/dev/null
        retry_out="$(virsh start "$vm" 2>&1)" && {
          echo "started_after_usb_cleanup"
          exit 0
        }
        echo "$retry_out" >&2
        exit 1
      args:
        executable: /bin/bash
      register: vm_started
      changed_when: "'started' in vm_started.stdout"

    - name: Wait for VM boot
      pause:
        seconds: 10

    - name: Resolve VM IP
      shell: |
        set -euo pipefail

        mac="$(virsh -c qemu:///system domiflist '{{ requested_vm_name }}' 2>/dev/null | awk 'NR > 2 && $5 ~ /^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$/ { print $5; exit }')"
        ip=""

        if [ -n "$mac" ]; then
          ip="$(virsh -c qemu:///system net-dhcp-leases default 2>/dev/null | awk -v mac="$mac" '
            BEGIN { IGNORECASE = 1 }
            $0 ~ mac {
              split($5, parts, "/")
              print parts[1]
              exit
            }
          ')"
        fi

        if [ -z "$ip" ]; then
          ip="$(virsh -c qemu:///system domifaddr '{{ requested_vm_name }}' 2>/dev/null | awk '
            /ipv4/ {
              split($4, parts, "/")
              print parts[1]
              exit
            }
          ')"
        fi

        echo "$ip"
      args:
        executable: /bin/bash
      register: vm_ip
      changed_when: false
      retries: 12
      delay: 5
      until: vm_ip.stdout != ""

    - name: Resolve SSH identity arguments from host SSH config
      shell: |
        set -euo pipefail

        ssh_config="/home/{{ requested_host_ssh_user }}/.ssh/config"
        if [ -f "$ssh_config" ]; then
          identity_lines="$(ssh -F "$ssh_config" -G "{{ vm_ip.stdout }}" 2>/dev/null | awk '/^identityfile / { print $2 }')"
        else
          identity_lines="$(ssh -G "{{ vm_ip.stdout }}" 2>/dev/null | awk '/^identityfile / { print $2 }')"
        fi

        printf '%s\n' "$identity_lines" \
          | sed "s#^~/#/home/{{ requested_host_ssh_user }}/#" \
          | awk 'NF && !seen[$0]++ { print }' \
          | while IFS= read -r key; do
              [ -f "$key" ] || continue
              case "$key" in
                *.pub) continue ;;
              esac
              printf -- "-o IdentityFile=%s " "$key"
            done
      args:
        executable: /bin/bash
      register: resolved_identity_args
      changed_when: false

    - name: Add dynamic SSH target host
      add_host:
        name: mount_shares_target
        groups: mount_shares_targets
        ansible_host: "{{ vm_ip.stdout }}"
        ansible_user: "{{ requested_vm_user }}"
        ansible_ssh_common_args: >-
          {{
            ((resolved_identity_args.stdout | trim) ~ ' ')
            if (resolved_identity_args.stdout | trim) != ''
            else ''
          }}-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
        share_data: "{{ detected_shares }}"

- name: Mount all shares in VM
  hosts: mount_shares_targets
  become: true
  gather_facts: false

  tasks:
    - name: Wait for SSH
      wait_for_connection:
        timeout: 300

    - name: Create mount point directories
      file:
        path: "{{ item.source }}"
        state: directory
        mode: '0755'
      loop: "{{ share_data }}"
      loop_control:
        label: "{{ item.source }}"

    - name: Mount shares
      shell: |
        set -euo pipefail
        mp="{{ item.source }}"
        tag="{{ item.tag }}"
        fstype="{{ item.fs_type }}"

        if mountpoint -q "$mp"; then
          echo "already_mounted"
          exit 0
        fi

        mount_share() {
          local fs="$1"
          if [ "$fs" = "9p" ]; then
            modprobe 9pnet_virtio >/dev/null 2>&1 || true
            modprobe 9pnet >/dev/null 2>&1 || true
            modprobe 9p >/dev/null 2>&1 || true
            mount -t 9p -o trans=virtio,version=9p2000.L,ro "$tag" "$mp"
          else
            modprobe virtiofs >/dev/null 2>&1 || true
            mount -t virtiofs -o ro "$tag" "$mp"
          fi
        }

        if mount_share "$fstype"; then
          echo "mounted:${fstype}"
          exit 0
        fi

        if [ "$fstype" = "9p" ]; then alt="virtiofs"; else alt="9p"; fi
        mount_share "$alt"
        echo "mounted:${alt}"
      args:
        executable: /bin/bash
      register: mount_result
      changed_when: "'mounted:' in mount_result.stdout"
      loop: "{{ share_data }}"
      loop_control:
        label: "{{ item.source }}"

    - name: Add fstab entries
      shell: |
        set -euo pipefail

        tag="{{ item.tag }}"
        mp="{{ item.source }}"

        if grep -qsF "$tag" /etc/fstab && grep -qsF "$mp" /etc/fstab; then
          echo "already_in_fstab"
          exit 0
        fi

        mounted_fs="$(findmnt -n -o FSTYPE "$mp" 2>/dev/null || true)"
        if [ "$mounted_fs" = "virtiofs" ]; then
          echo "${tag}  ${mp}  virtiofs  ro,nofail  0  0" >> /etc/fstab
        else
          echo "${tag}  ${mp}  9p  trans=virtio,version=9p2000.L,ro,nofail  0  0" >> /etc/fstab
        fi
        echo "added_to_fstab:${mounted_fs}"
      args:
        executable: /bin/bash
      register: fstab_result
      changed_when: "'added_to_fstab' in fstab_result.stdout"
      loop: "{{ share_data }}"
      loop_control:
        label: "{{ item.source }}"

    - name: Verify mounts
      command: df -h {{ item.source | quote }}
      register: df_result
      changed_when: false
      loop: "{{ share_data }}"
      loop_control:
        label: "{{ item.source }}"

    - name: Display results
      debug:
        msg: |
          {{ item.item.source }}: {{ item.stdout_lines | last }}
      loop: "{{ df_result.results }}"
      loop_control:
        label: "{{ item.item.source }}"
